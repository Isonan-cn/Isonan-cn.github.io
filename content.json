{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"links","text":"memset0:https://memset0.cnlyc:https://lnrbhaw.github.ioyx:https://www.cnblogs.com/DreamlessDreamsDilute:https://dilute.xyz","link":"/links/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"plans","text":"题目 文明 虚树做法 树`O(n^3)`做法 优秀的拆分 minimax 算法 类欧几里得 扩展KMP 文章 【学习笔记】后缀自动机 找相同字符 品酒大会 事情的相似度","link":"/plans/index.html"}],"posts":[{"title":"agc039f Min Product Sum 题解","text":"在$ n \\times m $的网格中填数，每个数为[1,k]的正整数。 对于一种填数方案，定义某一个位置的权值为与其同行或同列的所有位置中数的最小值。定义这种填数方案的权值为所有位置权值之积。 求所有方案权值之和。 $ 1 \\le n , m , k \\le 100$ 这个积非常难受，考虑其组合意义。可以将题意转化为：填两个$n\\times m$的网格，使得网格1中的任意一个位置$ \\le $网格2中与其同行或同列的所有位置。 这样还是不好dp，我们把行和列拆到两边： 填两个$n\\times m$的网格，使得网格1中的任意一个位置$ \\le $网格2中与其同列的所有位置，且网格2中的任意一个格子$ \\ge $网格1中与其同行的所有位置。 令$ f _ { i , j , k } $表示网格1恰有$j$行满足$ \\max \\le i$，网格2恰有$k$列满足$ \\min \\le i $时的权值。观察每个位置的限制何时被确定，可以得到： $ f _ { i , j , k } = $网格1恰有$j$行满足$ \\max \\le i$，网格2恰有$k$列满足$ \\min \\le i $时，将网格1中所有行或列至少一个被确定的位置、以及网格2中所有行与列均被确定的位置填上数，使其满足所有限制的方案数。 注意到行与列的转移是相对独立的，分开做即可$ \\Theta ( n ^ 4 ) $。 这里要注意先转移行再转移列，因为我们需要限制新加入的列$ \\min = i $，如果先转移列会出现方案中$=i$的位置还不能填的情况。行就没有这个困扰，因为行上需要填的位置是只减不增的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt; int n,m,k,P;inline int mul(const int &amp;a,const int &amp;b){return 1ll*a*b%P;}inline int sub(int a,const int &amp;b){a-=b;return (a&lt;0)?a+P:a;}inline int add(int a,const int &amp;b){a+=b;return(a&gt;=P)?a-P:a;}int f[2][101][101],C[101][101];int Pow[101][101];int main(){// n=100,m=100,k=100,P=998244353; scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;k,&amp;P); for(int i=0;i&lt;=100;++i){ C[i][0]=1; for(int j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]); } for(int i=0;i&lt;=100;++i){ Pow[i][0]=1; for(int j=1;j&lt;=100;++j) Pow[i][j]=mul(Pow[i][j-1],i); } f[0][0][0]=1; int u=0; for(int i=1;i&lt;=k;++i){ u^=1; memset(f[u],0,sizeof f[u]); for(int l=0;l&lt;=n;++l){ int v=mul(Pow[k-i+1][l],sub(Pow[i][n-l],Pow[i-1][n-l])); for(int d=0,V=1;d&lt;=m;++d,V=mul(V,v)) for(int j=d;j&lt;=m;++j) f[u][l][j]=add(f[u][l][j],mul(f[u^1][l][j-d],mul(C[m-j+d][d],V))); } u^=1; memset(f[u],0,sizeof f[u]); for(int l=0;l&lt;=m;++l){ int v=mul(Pow[i][m-l],sub(Pow[k-i+1][l],Pow[k-i][l])); for(int d=0,V=1;d&lt;=n;++d,V=mul(V,v)) for(int j=d;j&lt;=n;++j) f[u][j][l]=add(f[u][j][l],mul(f[u^1][j-d][l],mul(C[n-j+d][d],V))); } } printf(\"%d\\n\",f[u][n][m]);}","link":"/2021/07/17/agc039f/"},{"title":"2021 计蒜之道 精英组 决赛 Day2T2 题解","text":"对于非负整数 $ k $ ，定义数列 $ f $ ，满足 $$ f _ 0 = 0 , f _ 1 = 1 \\ f _ n=k f _ { n - 1 } + f _ { n - 2 } ( n &gt; 1 ) $$ 读入 $ n,k,d,m $ ，求 $$ \\sum _ {i=1}^{n} \\sum _ {j=1}^{i} [ i\\perp j ] ( f _ i , f _ { j + d } ) \\pmod m $$ $1\\le n\\le 10^6,0\\le k,d,m\\le 2^{30}$ 这里认为 $ (0,a)=a $。 首先可以发现对于任意非负整数 $ n,m $ ， $ (f_n,f_m)=f_{(n,m)} $。证明比较平凡，考虑 $ (a,b)=(a+b,b) $ 即可。 那么令$g=f*\\mu$，则有 $$\\sum_{i=1}^{n}\\sum_{j=1}^{i} [ i\\perp j ] (f_i,f_{j+d}) \\ =\\sum_{i=1}^{n}\\sum_{j=1}^{i} [ i\\perp j ] f_{(i,j+d)} \\ =\\sum_{i=1}^{n}\\sum_{j=1}^{i} [ i\\perp j ] \\sum_{q|i,q|j+d}g_q \\ =\\sum_{q=1}^{n}g_q\\sum_{i=1,q|i}^{n}\\sum_{j=1}^{i} [ i\\perp j ] [ q|j+d ] \\ =\\sum_{q=1,q\\perp d}^{n}g_q\\sum_{i=1,q|i}^{n}\\sum_{j=1}^{i} [ {i\\over (i,q^\\infty)}\\perp j ] [ q|j+d ] \\ =\\sum_{q=1,q\\perp d}^{n}g_q\\sum_{i=1,q|i}^{n}\\sum_{j=1}^{i} [ q|j+d ] \\sum_{r|{i\\over (i,q^\\infty)}}\\mu(r) [ r|j ] \\ =\\sum_{q=1,q\\perp d}^{n}g_q\\sum_{i=1,q|i}^{n}\\sum_{r|{i\\over (i,q^\\infty)}}\\mu(r)\\sum_{j=1}^{i} [ q|j+d ] [ r|j ]$$ 注意到$q\\perp r$，所以在$r,2r,\\dots,i$中恰好有$i\\over qr$个$j$满足$[q|j+d]$。于是 $$原式=\\sum_{q=1,q\\perp d}^{n}g_q\\sum_{i=1,q|i}^{n}\\sum_{r|{i\\over (i,q^\\infty)}}\\mu(r){i\\over qr} \\ =\\sum_{q=1,q\\perp d}^{n}g_q\\sum_{r\\perp q}\\mu(r)S_{\\lfloor{n\\over qr}\\rfloor}$$ 这里$S_i=1+2+\\dots+i$。 该式可以在$O(n\\log \\log n)$内解决。","link":"/2021/06/14/jisuanke-18906-t2/"}],"tags":[{"name":"OI","slug":"OI","link":"/tags/OI/"}],"categories":[]}